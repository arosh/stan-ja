## 5. 文（ステートメント）

<!-- 2.17.1の5章を参照しました。 -->

Stanプログラムのブロック（6章を参照）は、変数の宣言と文（ステートメント）とから成り立っています。BUGSのプログラムとは違って、Stanプログラム中の宣言と文はそれらが記載された順序で実行されます。変数は、それが参照される前に何らかの値 (と何らかのデータ型の宣言)
によって定義されていなければいけません。そうでない場合、実行結果は未定義となります。

Stanでは、与えられた（実数値の）パラメーターの組についての対数確率関数（具体的には確率密度関数）の評価が実行の基礎です。対数確率関数は、代入文を使って組み立てることができます。
また、連続した処理やfor-eachループの繰り返し処理のため複数の文をグルーピングできます。加えて、Stanでは ブロック内でのローカル変数の宣言や、セミコロンのみからなる空の文も許容されています。

### 5.1. 文のブロックの文脈

`data`と`parameters`ブロックにはどんな種類の文も置けません。これらのブロックは、入力するデータ変数とサンプリングのためのパラメーター変数の宣言に使うためだけにあるからです。他のブロックはすべて文を置くことができます。これらのブロックでは、変数宣言と文の両方を置くことができます。変数宣言ではない最初の文により、ブロックの変数宣言のリストが終わります。Stanのプログラムでのブロックの構造についてさらに知るには第6章を参照してください。

### 5.2. 代入文

代入文は変数と式からなります。変数はインデックス情報を持つ多変量の場合もあります。
代入文が実行されると、文の右辺にある式が評価され、
その結果が左辺の変数 (インデックスがある場合は指定された箇所) に代入されます。
簡単な代入の例は以下のようなものです。^[Stan の 2.16.0 より前のバージョンでは、代入には等号 `=`ではなく `<-` 演算子が用いられていました。
古い`<-` 演算子は現在では非推奨となり警告が表示されます。`<-` 演算子は将来のバージョンで削除されます。]

<!--
以降も原文には都度 (indexed) の記載があるが、日本語で簡潔に記載できる語がないため省略
-->

```
n = 0;
```

この文が実行されると、式`0`、つまり 整数のゼロが評価され、変数`n`に代入
されます。代入が成立するためには、右辺の式のデータ型と左辺の変数のデータ型は一致していな
ければなりません。上の例では、`0`という式は`int`型になるため、
変数`n`は`int`型もしくは`real`型で宣言されていなければなりません。
変数が`real`型で宣言されている場合は、整数のゼロは浮動小数点のゼロに変換されて
変数に代入されます。文が実行された後は、変数`n`はゼロ (変数のデータ型に応じて整数
もしくは浮動小数点) という値を持ちます。

構文上、すべての代入文はセミコロンで終わっていなければなりません。
それ以外では、トークンの間の空白は処理に影響しません (ここでのトークンは左辺の変数、
代入演算子、右辺の式、セミコロンを指します)。

右辺の式が最初に評価されるため、Stan でも C++ や他のプログラミング言語と同じように
変数を変数をインクリメントすることができます。

```
n = n + 1;
```

このような自己代入は BUGS では許されていません。なぜなら、自己代入は
有向グラフィカルモデル中で循環を引き起こすからです。

代入文の左辺は配列、`matrix`、`vector`といったデータ構造に対するインデックスを
含むことがあります。例えば、`matrix`として定義された`Sigma`に対して、

```
Sigma[1, 1] = 1.0;
```

という代入文は、`Sigma`の1行1列目の値に1を代入します。

代入文にはあらゆるデータ型の複雑なオブジェクトを含むことができます。
`Sigma`と`Omega`が`matrix`、`sigma`が`vector`の場合、次の代入文は
成立します。変数のデータ型と式の結果はどちらも `matrix`型になるためです。

```
Sigma
  = diag_matrix(sigma)
     * Omega
     * diag_matrix(sigma);
```

また、この例は複雑な代入文を複数の行に分割して記載する場合に望ましい例を
示しています。

Stan は より大きな多変量のデータ構造の一部に対する代入もサポートしています。例えば、
`a`が`real[ , ]`型の配列、`b`が`real[]` 型の配列の場合、以下二つの
代入文はどちらも成立します。

```
a[3] = b;
b = a[4];
```

同じように、`x`が`row_vector`型、`Y`が`matrix`型の変数として
宣言されている場合、次の一連の処理は成立します。処理の結果、`Y`の最初の2行が
入れ替わります。

```
x = Y[1];
Y[1] = Y[2];
Y[2] = x;
```

#### 左辺値

代入文中の左辺として適切な式を“左辺値”と呼びます。Stan では、
適切な左辺値は以下の 2 種類しかありません。

- 一つの変数
- 一つ以上のインデックスを持つ一つの変数

インデックスのついた変数を左辺値として使うためには、その変数は少なくともインデックスと同じ数の
次元を持っていなければいけません。実数型や整数型の配列は宣言された数の次元を持ちます。
行列（`matrix`）は2次元、行列（`vector`）や列行列（`row_vector`）は1次元です。これは制約のついた型でも同様で、共分散行列（`cov_matrix`）と
相関行列（`corr_matrix`）、またそれらのコレスキー因子（`cholesky_factor_cov`、`cholesky_factor_corr`）や、順序つき（`ordered`）、正の順序つき（`positive_ordered`）、単体（`simplex`）のベクトルについてもあてはまります。
通常の配列と比べると、行列の配列の次元数は2だけ大きく、ベクトルや列ベクトルの配列の次元数は1だけ大きくなります。
インデックスの数は、変数の次元数よりも少なくてもよいことに注意してください。
このとき、右辺自身も多次元で、左辺の残りの次元と一致している必要があります。

#### マルチプルインデックス

マルチプルインデックスは4.8節で説明していますが、これも代入の左辺に使うことができます。左辺のインデックス操作は、式と同じように機能します。
このとき、マルチプルインデックスはインデックスの位置を保存し、シングルインデックスはインデックスを減少させます。
左辺の型はやはり右辺の型と一致していなくてはなりません。

##### エイリアス

すべての代入は、事前に右辺の式のをコピーしたかのようにして行われます。
これにより、「代入文の実行中に右辺の式の値が変更される」ことによって生じる、
エイリアスの潜在的な問題を解決しています。

#### 複合算術代入文

Stanの算術演算子は、算術演算子と代入演算子を複合させたものとして使うことができます。例えば、加算と代入を複合させた以下の例を考えます。

```
real x = 5;
x += 7;  // xの値は12になります
```

上の複合算術代入文は以下の長い形式と等価です。

```
x = x + 7;
```

一般に、複合した形式

```
x op= y;
```

は

```
x = x op y;
```

と等価です。
複合代入文は、長い形式が有効な場合にはいつでも有効です。必要なのは、演算`x op y`がそれ自身正しいこと、かつ、演算の結果が`x`に代入可能であることです。代入可能な式`x`は、現在のブロックで定義されているインデキシングされた変数でなくてはなりません。例えば、以下の複合加算代入文は、ベクトルの1個の要素に2を加算します。

```
vector[N] x;
x[3] += 2;
```

さらに例を挙げましょう。

```
matirx[M, M] x;
vector[M] y;
real z;
x *= x;  // OK, (x * x)は行列
x *= z;  // OK, (x * z)は行列
x *= y;  // ダメ, (x * y)はベクトル
```

サポートされている複合算術代入演算子のリストは図5.1にあります。索引でも、`operator+=`のように`operator`という接頭語を付けて掲載してあります。

| 演算           | 複合形式  | 長い形式     |
|----------------|-----------|--------------|
| 加算           | `x += y`  | `x = x + y`  |
| 減算           | `x -= y`  | `x = x - y`  |
| 乗算           | `x *= y`  | `x = x * y`  |
| 除算           | `x /= y`  | `x = x / y`  |
| 要素ごとの乗算 | `x .*= y` | `x = x .* y` |
| 要素ごとの除算 | `x ./= y` | `x = x ./ y` |

図5.1: Stanでは、上の表に載せた形式の複合算術代入文が使用できます。複合形式は、対応する長い形式が使えるところならどこでも使え、同じ効果を持ちます。

### 5.3. 対数密度加算文

Stanでは、与えられた（実数値の）パラメーターの組についての対数確率関数（具体的には確率密度関数）の評価が実行の基礎です。
この関数は、加算する定数を除いて事後分布の対数密度を返します。
データと変換データは対数密度が評価される前に決められます。
対数確率の合計は0に初期化されます。
次に、対象の変数に制約がある場合に生じる対数ヤコビアンの調整が対数密度に対して加えられます 
(ヤコビアンの調整は最適化のために省略されることがあります)。
`model`ブロックでは、サンプリング文と対数確率加算文で対数密度への加算を行なうことができます。
対数確率加算文は、以下のような式の値を対数密度に直接加算します。^[この現在の記法は過去のふたつのバージョンに代わるものです。
元々は、変数`lp__`を直接参照したり操作することができました。これはもはや許可されていません。
`target += u`に対応する元の文法は`increment_log_prob(u)`ですが、この形式は非推奨となり Stan 3 で削除されます。]

```
target += -0.5 * y * y;
```

ここでの`target`というキーワードは実際には変数ではなく、変数のようにアクセスすることはできません
(が、特殊な関数を使って`target`の値に直接アクセスする方法がこの後にあります)。

この例では、標準正規分布にしたがう変数`y`の標準化されていない対数確率が対数確率の合計に加算されます。
一般的には、右辺はどのような式にもなりえます。^[乗算のほうが除算よりも効率的なため、このモデルでは式を`-0.5 * y * y`と書いたほうが、等価な`y * y / -2`よりも効率的です。
どちらの場合も、負数化は数値リテラル（`-0.5`や`-2`）に含められます。
`y * y`の代わりに`square(y)`と書くと導関数を事前に計算でき、
利用メモリと自動微分に必要な操作も減らすことができるためさらに効率的です。]

完全なStanモデルをこのようにして実装することができます。
たとえば、次のモデルは標準正規分布に従うひとつの変数を抽出します。

```
parameters {
  real y;
}
model {
  target += -0.5 * y * y;
}
```

このモデルでは対数確率関数を以下ように定義しています。

$$\log p(y) = -\frac{y^2}{2} - \log Z$$

ここで、$Z$は$y$に依存しない正規化定数です。
定数$Z$は慣例的にこのように書かれます。これは、線形スケールでの式が以下のようになるからです。

$$p(y) = \frac{1}{Z} \exp\left(-\frac{y^2}{2}\right)$$

上の式は通常は$Z$を使わず以下のように書かれます。

$$p(y) \propto \exp\left(-\frac{y^2}{2}\right)$$

Stanでは、パラメーターに依存しない定数を除いて定義したモデルしか必要としません。
正規化定数$Z$の計算には時間がかかったり評価がしにくいことがしばしばあるため、これは便利です。

#### ベクトル化

`target += ...`文は、`...`の部分の引数にどんな式でも入れることができます。
これには、整数、実数、ベクトル、列ベクトル、行列のほか、ベクトルや行列の配列を含むあらゆる次元数の配列を含みます。
引数がコンテナ型の場合はその要素の合計が対数密度に加算されます。

#### 対数密度へのアクセス

現在の実行ポイントの直前までの累積対数密度にアクセスするには`target()`関数を使うことができます。

### 5.4. サンプリング文

Stanでは、以下のようなサンプリング記法でも確率文を書くことができます。

```
y ~ normal(mu,sigma);
```

「サンプリング文」という名前は示唆的な意味であり、文字通りに解釈するものではありません。
概念的には、変数`y`は、未知のパラメーターでも既知のモデリングされるデータでもよく、サンプリング文の右辺で示される分布を持つと宣言されています。

このような文を実行してもサンプリングはまったく行なわれません。Stanでは、サンプリング文は単に便利な記法に過ぎません。上のサンプリング文は以下と同様で、対数確率の合計に直接加算するということを表します。

```
target += normal_lpdf(y | mu, sigma);
```

一般に、以下の形式のサンプリング文

```
y ~ dist(theta1, ..., thetaN);
```

は、`y`と`theta1`から`thetaN`（`N`が0の場合も含みます）までの部分式からなり、対応する代入文が整形式の場合にのみ整形式となります。`y`の値が実数でよい密度については、以下のような対数確率密度関数が使われます。

```
target += dist_lpdf(y | theta1, ..., thetaN);
```

`y`の値が整数に制限されている場合は、対数確率質量関数が使われます。

```
target += dist_lpmf(y | theta1, ..., thetaN);
```

これは、`dist_lpdf(y | theta1, ..., thetaN)`あるいは`dist_lpmf(y | theta1, ..., thetaN)`が`real`型の整形式の式である場合にのみ、整形式となります。

#### 対数確率加算 vs. サンプリング文

以下のようなサンプリング文でも、

```
y ~ normal(mu, sigma);
```

以下のように対数確率関数を明示的に加算しても、

```
target += normal_lpdf(y | mu,sigma);
```

Stanでのサンプリングの挙動は同じになりますが、両者の間には1つ決定的な違いがあります。

サンプリング文は、定数となる対数確率関数の項をすべて捨てますが、明示的に`normal_lpdf`を呼ぶ場合には、定数の正規化項もすべて含め、対数正規確率関数の定義の項すべてを加算します。
したがって、明示的に加算する形式は、モデルの正確な対数確率の値を生成しなおすために使うことができます。一方、サンプリング文の形式は、入力の式である`y`や`mu`、`sigma`のすべてが定数、データ変数、変換データ変数だけからなる場合にはより高速です。

#### ユーザー定義の変数変換

サンプリング文の左辺は複合的な式でも構いません。たとえば、構文上正しく以下のように書けます。

```
parameters {
  real<lower=0> beta;
}
// ...
model {
  log(beta) ~ normal(mu, sigma);
}
```

残念ながら、このように書いても、`beta`が対数正規分布に従うと正しくモデリングしたことにはなりません。この例での`beta`に対数関数を適用する場合のように、非線形の変換をパラメーターに適用するときにはいつでも、微分の変化の帳尻を合わせ、`beta`が正しい分布となることを保証するため、調整を行なわなくてはなりません。必要な補正とは、変換の対数ヤコビアンを目的の対数密度に加算することです（完全な定義は34.1節を参照してください）。上の場合では、以下の調整が対数変換の補正となります。^[$\log |\frac{d}{dy}\log y | = \log | 1 / y | = -\log | y |$だからです。34.1節を参照してください。]

```
target += - log(fabs(y));
```

#### 切断分布

Stanでは、上限、下限、あるいは上下限のある切断分布を使えます。

##### 上限と下限での切断

連続分布の確率密度関数$p(x)$を区間$[a, b]$で切断して、$[a, b]$を台とする新しい密度$p_{[a, b]}$を定義できます。

$$p_{[a, b]}(x) = \frac{p(x)}{\int_a^b p(u)du}$$

離散分布の確率質量関数$p(x)$を閉区間$[a, b]$で切断できます。

$$p_{[a, b]}(x) = \frac{p(x)}{\sum_{u=a}^b p(u)}$$

##### 下限での切断

確率密度関数$p(x)$は以下の定義により$[a,\infty]$で切断できます。

$$p_{[a, \infty]}(x) = \frac{p(x)}{\int_a^\infty p(u)du}$$

確率質量関数$p(x)$は以下の定義により$[a,\infty]$で切断できます。

$$p_{[a, \infty]}(x) = \frac{p(x)}{\sum_{a<=u} p(u)du}$$

##### 上限での切断

確率密度関数$p(x)$は以下の定義により$[-\infty, b]$で切断できます。

$$p_{[-\infty, b]}(x) = \frac{p(x)}{\int_{-\infty}^b p(u)du}$$

確率質量関数$p(x)$は以下の定義により$[-\infty, b]$で切断できます。

$$p_{[-\infty, b]}(x) = \frac{p(x)}{\sum_{u<=b} p(u)du}$$

##### 累積密度関数

確率変数$X$についての確率関数$p_X(x)$が与えられたとき、その累積密度関数(cumulative distribution function: cdf)$F_X(x)$は、$X \le x$である確率として定義されます。

$$F_X(x) = \Pr[X \le x]$$

大文字の変数$X$は確率変数ですが、小文字の変数$x$は、範囲に限度のあるごく普通の変数です。連続値の確率変数については、cdfは以下のようになります。

$$F_X(x) = \int_{-\infty}^x p_X(u)du$$

離散値の変数については、cdfは引数で与えられた上限を含めて定義されます。

$$F_X(x) = \sum_{u \le x}p_X(u)$$

##### 相補累積分布関数

相補累積分布関数(complementary cumulative distribution function: ccdf)は、連続の場合も離散の場合も以下のようになります。

$$F_X^C(x) = \Pr[X > x] = 1 - F_X(x)$$

cdfとは異なり、ccdfは境界を含みません。cdfの事象は$X \le x$ですが、ccdfの事象は$X > x$だからです。

連続分布については、ccdfは以下のようになります。

$$F_X^C(x) = 1 - \int_{-\infty}^x p_X(u)du = \int_x^\infty p_X(u)du$$

積分の境界には下限を含めることができます。線上の1点であり、確率質量を持たないからです。
離散の場合は、$u > x$について総和をとる際に明示的に下限を除外しなければなりません。

$$F_X^C(x) = 1 - \sum_{u \le x} p_X(u) = \sum_{u > x} p_X(u)$$

累積分布関数は、切断分布を定義するのに必要な積分の計算に使われます。
上下限での切断では、分母は以下のように定義されます。

$$\int_a^b p(u)du = F_X(b) - F_X(a)$$

離散分布では、下の切断点が含まれない$F_X(b)-F_X(a)$に、この点を明示的に入れるためにやや複雑な形が必要です。

$$p_{[a, b]}(x) = \frac{p_X(x)}{F_X(b) - F_X(a) + p_X(a)}$$

##### Stanにおける上下限での切断

Stanでは確率関数を切断することができます。たとえば、$[-0.5, 2.1]$に制約される切断標準正規分布は以下のサンプリング文でコーディングできます。

```
y ~ normal(0, 1) T[-0.5, 2.1];
```

切断分布は、累積対数密度関数の追加の項に、サンプリング文中の変量が切断の上下限に含まれていることを保証するためのエラーチェックを加えて翻訳されます。

一般に、切断の上下限とパラメーターは、パラメーターあるいは局所変数でも構いません。

上の例は連続分布からなっているので、以下のより冗長な形式と同じ動作となります。

```
y ~ normal(0, 1);
if (y < -0.5 || y > 2.1)
  target += negative_infinity();
else
  target += -log_diff_exp(normal_lcdf(2.1 | 0, 1),
                          normal_lcdf(-0.5 | 0, 1));
```

Stanプログラムは対数密度関数を定義しますから、すべての計算は対数スケールで行なわれます。
`normal_lcdf`関数は累積正規分布関数の対数で、`log_diff_exp(a, b)`は、`log(exp(a) - exp(b))`をより算術的に安定にした形です。

離散分布では、下限を除くために分母にもうひとつの項が必要です。
以下の切断離散分布

```
y ~ poisson(3.7) T[2, 10];
```

は、以下のコードと同じ動作となります。

```
y ~ poisson(3.7);
if (y < 2 || y > 10)
  target += negative_infinity();
else
  target += -log_sum_exp(poisson_lpmf(2 | 3.7),
                         log_diff_exp(poisson_lcdf(10 | 3.7),
                                      poisson_lcdf(2 | 3.7)));
```

`log_sum_exp(a, b)`は、`log(exp(a) + exp(b)`を単に算術的に安定な形にしたものであることを思い出してください。

##### Stanにおける下限での切断

下限だけで切断するには、上限を空白のままにします。

```
y ~ normal(0, 1) T[-0.5, ];
```

切断されたサンプリング文は以下のコードと同じ動作です。

```
y ~ normal(0, 1);
  if (y < -0.5)
    target += negative_infinity();
  else
    target += -normal_lccdf(-0.5 | 0, 1);
```

`normal_lccdf`関数は正規相補累積分布関数です。

上下限の切断がある場合と同じく、離散の場合には、下限の確率質量を足し戻すために分母がより複雑になります。

```
y ~ poisson(3.7) T[2, ];
```

は、以下と同じ動作です。

```
y ~ poisson(3.7);
if (y < 2)
  target += negative_infinity();
else
  target += -log_sum_exp(poisson_lpmf(2 | 3.7),
                         poisson_lccdf(2 | 3.7));
```

##### Stanにおける上限での切断

上限だけで切断するには、下限を空白のままにします。
上限で切断されるサンプリング文

```
y ~ normal(0, 1) T[ , 2.1];
```

は以下のコードと同じ結果を生成します。

```
target += normal_lpdf(y | 0, 1);
if (y > 2.1)
  target += negative_infinity();
else
  target += -normal_lcdf(2.1 | 0, 1);
```

上限だけがあるときには、離散の場合も境界の補正は必要ありません。
上限で切断されるサンプリング文

```
y ~ poisson(3.7) T[ , 10];
```

は以下のコードと同じ挙動となります。

```
y ~ poisson(3.7);
if (y > 10)
  target += negative_infinity();
else
  target += -poisson_lcdf(10 | 3.7);
```

##### 累積分布は定義する必要があります

どんな場合でも、適切な対数密度関数あるいは対数質量関数と必要な対数累積分布関数が定義されているときにだけ切断は整形式になります。
Stanに組込みのすべての分布で対数cdfおよび対数ccdfが定義されているわけではありませんし、ユーザー定義関数ではまったく定義されていないでしょう。
第3部および第4部では、利用可能な離散および連続の累積分布関数を記述しています。ほとんどの1変量分布には対数cdf関数および対数ccdf関数があります。

##### 上下限の型の制約

連続分布では、切断点は`int`型か`real`型の式でなくてはなりません。離散分布では、切断点は`int`型の式でなくてはなりません。

##### 切断の上下限外の変量

切断サンプリング文では、サンプリングされた値が切断の式で指定された上下限内にない場合には、結果は確率0となり、文全体では合計対数確率に$-\infty$を加えます。これは次にサンプルが却下される結果となります。すべての値を上下限内に保つプログラミング戦略のための、制約と、範囲外の返り値に関する議論については12.2節中の小節を参照してください。

##### 切断分布のベクトル化

Stanは、切断のある分布関数のベクトル化を（まだ）サポートしていません。

### 5.5. forループ

`N`が`int`型の変数、`y`が`real[]`型の1次元配列、`mu`と`sigma`が`real`型の変数であるとします。
さらに、`n`は変数として定義されていないとします。すると、以下は整形式のforループ文となります。

```
for (n in 1:N) {
  y[n] ~ normal(mu, sigma);
}
```

このときのループ変数は`n`で、ループの範囲は`1:N`の値であり、本体はループの範囲に続く文です。

#### ループ変数の型付けとスコープ

ループの上下限は整数でなければなりません。Rとは異なり、Stanのループは常にカウントが増加するループと解釈されます。
範囲を`L:H`とした場合、ループ変数が`L`以上`H`以下の整数値すべてをとりつつループが実行されます。
たとえば、`for (n in 2:5)`というループでは、`n`が順番に2, 3, 4, 5という値をとりつつループの本体が実行されます。`for (n in 5:2)`という変数と範囲では、5以上2以下の整数が存在しないので、何も実行されません。

#### 順序依存性と変数の再使用

BUGSとは異なり、Stanでは変数に再代入することができます。
たとえば、以下のプログラムの変数`theta`はループの各iterationで再代入されます。

```
for (n in 1:N) {
  theta = inv_logit(alpha + x[n] * beta);
  y[n] ~ bernoulli(theta);
}
```

このような再代入はBUGSでは認められていません。
BUGSではforループは宣言です。有向グラフィカルモデルの記法におけるプレートを定義するもので、グラフィカルモデルにおける繰り返しの下部構造と考えることができます。
したがってBUGSやJAGSでは、変数に値を繰り返し再代入するようなforループは違反となります。^[BUGSコードのプログラミング手法では、上の例の`theta`を`theta[n]`で置き換えることで局所変数をシミュレートします。これにより`N`個の別々の変数`theta[1],...,theta[N]`をうまくつくることができます。もちろん、`theta[n]`の値がすべての`n`について必要ならばこれはハックではありません。]

Stanでは、代入は出現順に実行されます。
したがって、以下のStanプログラムは上のものとはまったく別に解釈されます。

```
for (n in 1:N) {
  y[n] ~ bernoulli(theta);
  theta = inv_logit(alpha + x[n] * beta);
}
```

このプログラムでは、`theta`は確率文で使われた後に代入されます。
このとき、最初のループのiterationより前に`theta`が定義されていることを前提として仮定しています（さもなくば、動作は未定義です）。そして各ループでは、前のiterationでの代入を利用しています。

Stanのループは、値を積算するために使うこともできます。
したがって、以下のようなコードを使って配列の値を直接合計することができます。

```
total = 0.0;
for (n in 1:N)
  total = total + x[n];
```

ループの実行後には、`total`変数には`x`配列の要素の合計が入っているでしょう。
この例は純粋に教育的なものです。以下のように書いた方がより簡単で効率的です。

```
total = sum(x);
```

ループ内の（外のも）変数は何度でも再代入できます。以下も正しいコードです。

```
for (n in 1:100) {
  y = y + y * epsilon;
  epsilon = epsilon / 2.0;
  y = y + y * epsilon;
}
```

### 5.6. 条件文

Stanでは、C++と同じif-then-else構文を使って、完全な条件文を使うことができます。
以下が一般的なフォーマットです。

```
if (条件1)
  文1
else if (条件2)
  文2
// ...
else if (条件N-1)
  文N-1
else
  文N
```

最初の1個の`if`節は必須です。続けて、任意の個数の`else if`節を置くことができます。これらすべての後に任意で`else`節を置くことができます。
各条件は実数値あるいは整数値でなければなりません。非零値は真と解釈され、零値は偽と解釈されます。

一連のif-then-else節全体で、評価される単一の条件文が構成されます。
条件のひとつが非零値と評価されるまで、一連の条件は順に評価されます。非零値と評価されたところで、それに対応する文が実行され、条件文は実行を終えます。
どの条件も非零値と評価されず、かつ最後にelse節があるときは、その文が実行されます。

### 5.7. while文

Stanでは、C++と同じ構文で標準的なwhileループを使うことができます。
以下が一般的なフォーマットです。

```
while (条件)
  本体
```

条件は整数または実数の式でなくてはいけません。本体はどんな文（あるいは波括弧に囲まれた一連の文）でも構いません。

whileループの評価は、条件の評価から始まります。
条件が偽（零）値と評価された場合は、ループの実行は終了し、制御はループの後に移動します。
ループの条件が真（非零）値と評価された場合は、本体の文が実行されます。そして、whileループが再度実行されます。
このようにして、条件が真値と評価されるまでループは継続して実行されます。

### 5.8. 文のブロックと局所変数の宣言

丸括弧が式をグループ化するのに使われるのとまったく同じように、0個以上の一連の文をグループ化するのに波括弧を使うことができます。
各ブロックの最初では、局所変数を宣言することができます。そのスコープはそのブロック中の残りの文となります。

#### forループ中のブロック

ブロックは、forループの本体で、一連の文をブロック化してまとめるのによく使われます。
forループの本体はどんな文でも構いませんから、1個だけの文からなる本体を持つforループは以下のように書けます。

```
for (n in 1:N)
  y[n] ~ normal(mu,sigma);
```

forループの本体中に複数の文を含めるためには、以下の例のようにブロックが使われます。

```
for (n in 1:N) {
  lambda[n] ~ gamma(alpha,beta);
  y[n] ~ poisson(lambda[n]);
}
```

開く波括弧（`{`）がブロックの最初の文字で、閉じる波括弧（`}`）が最後の文字になります。

空白文字はStanでは無視されますから、以下のプログラムはコンパイルされません。

```
for (n in 1:N)
  y[n] ~ normal(mu, sigma);
  z[n] ~ normal(mu, sigma); // エラー!
```

問題は、forループの本体が、直後の文`y[n] ~ normal(mu, sigma);`となることです。
そのため、`z[n]`の確率文が宙に浮いてしまいます。以下の等価なプログラムにするとよくわかります。

```
for (n in 1:N) {
  y[n] ~ normal(mu, sigma);
}
z[n] ~ normal(mu, sigma); // エラー!
```

どちらのプログラムもコンパイルされません。
ループ変数`n`がforループの前に定義されていた場合には、forループの宣言がエラーを発生させます。
ループ変数`n`がforループの前に定義されていない場合には、式`z[n]`の使用がエラーを発生させます。

#### 局所変数の宣言

forループは本体として文を持ちます。
プログラムを書くときには、一時的に使って、その後は忘れるような局所変数を定義できると便利なことがよくあります。
たとえば、繰り返し代入を行なうforループの例では、明晰さと効率を最大化するために局所変数を使うべきでしょう。以下がその例です。

```
for (n in 1:N) {
  real theta;
  theta = inv_logit(alpha + x[n] * beta);
  y[n] ~ bernoulli(theta);
}
```

局所変数`theta`はここではforループの中で宣言されています。
局所変数のスコープは、定義されているブロックの中だけです。
したがって、`theta`はこのforループの中だけで使用可能で、外では使用不可です。
これ以外の状況では、Stanは変数の隠蔽を許していません。
ですから、変数`theta`がforループのスコープ内ですでに定義されている場合には、局所変数`theta`の宣言は違反となります。
たとえば、以下は正しくありません。

```
for (m in 1:M) {
  real theta;
  for (n in 1:N) {
    real theta; // エラー!
    theta = inv_logit(alpha + x[m, n] * beta);
    y[m, n] ~ bernoulli(theta);
// ...
```

コンパイラーは、2番目の`theta`の宣言にフラグを立て、すでに定義されているというメッセージを出します。

#### 局所変数には制約をつけられません

局所変数の宣言には制約をつけられません。
使用可能な型は以下だけです。

```
int, real, vector[K], row_vector[K], matrix[M, N]
```

#### ブロックの中のブロック

ブロックはそれ自身が文ですから、一連の文が使用可能な場所では、1個以上の文をブロックにできます。
たとえば、forループでは、以下は正しい例です。

```
for (m in 1:M) {
  {
    int n;
    n = 2 * m;
    sum = sum + n;
  }
  for (n in 1:N)
    sum = sum + x[m, n];
}
```

変数宣言の`int n;`は埋め込まれたブロックの最初の要素ですから、スコープはそのブロック内となります。
forループは、それに続く文に対して自身の局所ブロックを暗黙に定義します。そのブロックの中でループ変数が定義されます。
Stanに関しては、上のふたつの`n`の使用は無関係です。

### 5.9. break文とcontinue文

1個のトークンの文`continue`と`break`を、ループ内での制御の流れを変えるために使うことができます。`continue`は、ループの次のiterationをすぐに実行させます。一方、`break`はループを終了させ、ループの後で実行を再開させます。
どちらの制御構造もループ中に置かなくてはなりません。
`break`と`continue`のどちらもスコープはもっとも深くネストしたループとなりますが、ループでない文は無視します。

これらの制御構造は、gotoのような動作のために、好ましくないと思われることがあります。しかし、思慮深く使うと、ネスティングのレベルを減少させ、ループ内の計算を減らして、可読性をおおいに改善することができます。

#### break文

`break`文が実行されると、現在実行中のもっとも深くネストしたループが終了させられ、そのループの後の次の文が実行されます。
たとえば、以下のプログラムを考えます。

```
while (1) {
  if (n < 0) break;
  foo(n);
  n = n - 1;
}
```

`while (1)`ループは無限ループです。`1`は真値なので、条件判断は常に成功するからです。
ループ内では、`n`の値が0より小さくなるとループを終了し、そうでなければ`foo(n)`を実行してから`n`をデクリメントします。
上の文は以下とまったく同じものです。

```
while (n >= 0) {
  foo(n);
  n = n - 1;
}
```

この例は単に動作を示したものですので、`break`がループを簡潔にした例とはなっていません。

#### coninue文

`continue`文はループ内で実行中の操作を終了させ、ループの最初にある条件判断に戻ります。
このようなループは典型的には、いくつかの値を計算させないために使われます。
たとえば、以下のループは、配列`x`内の正の値合計するのに使われています。

```
real sum;
sum = 0;
for (n in 1:size(x)) {
  if (x[n] <= 0) continue;
  sum = sum + x[n];
}
```

`continue`文が実行されると、ループの条件判断部まで制御がジャンプして戻ります。
whileとforループでは、これにより、ループの条件節へ制御が戻ります。
forループではこれはループ変数を進めますから、0よりも小さい`x[n]`が出てきても、上のプログラムは無限ループにはなりません。
したがって、上のプログラムは、条件を反転させてネストを深くする形に書き直すことができます。

```
real sum;
sum = 0;
for (n in 1:size(x)) {
  if (x[n] > 0)
    sum = sum + x[n];
}
```

この単純な例では、後の形の方がより読みやすいように見えるかもしれませんが、実行するメインの行のネストは前者の方が1段少なくなっています。
そのかわり、トップの条件節は排除する場合を見つけるようになっており、後者の、排除しない場合のコードと同じレベルのネスティングを必要としません。
このような排除条件がいくつかあるときには、`break`や`continue`を使ったバージョンの方が読みやすくなる傾向にあります。

#### ネストしたループでのbreakおよびcontinue

ループの中にネストしたループがある場合は、`break`あるいは`continue`文は内側のループだけに関係します。

```
while (条件1) {
  ...
  while (条件2) {
    ...
    if (条件3) break;
    ...
  }
  // break後の実行はここから
  ...
```

`条件3`が真になったために`break`が発生した場合は、ネストしたループの後から実行が続きます。

`break`文と同様、`continue`文は、その`continue`が置かれているもっとも深くネストしたループのトップに戻ります。

`break`も`continue`もループの中に置かなくてはなりませんが、ループ内のネストした文の間に置くこともできます。たとえば、上の条件節の間や、ネストした文の間に置くことができます。
`break`と`continue`文は、whileループとforループ以外の既存の制御構造はすべてジャンプします。

### 5.10. print文

Stanには、リテラル文字列と式の値をプリントできるprint文があります。
print文の引数の数は任意です。
以下の、本体にprint文があるfor-each文を考えてみましょう。

```
for (n in 1:N) { print("ループのiteration: ", n); ... }
```

print文は、ループの本体が実行されるたびに実行されます。
ループの本体が実行されるたびに、"ループのiteration:"という文字列が（後続の空白とともに）プリントされ、その後に式`n`の値が続き、最後に改行されます。

#### プリント内容

print文でプリントされるテキストは、その内容により異なります。
print文中のリテラル（すなわち引用符のついた）文字列は常にそのままの文字列として（引用符は除いて）プリントされます。
print文中の式は、式の値がプリントされることになります。
しかし、式の値がどのように整形されるかは型によって異なります。

単純な`real`型や`int`型の変数では、変数の値がプリントされます。^[モデル中のパラメーター、変換パラメーター、局所変数を実装するのに使われるアルゴリズム的微分変数については、随伴行列の成分は実行中は常に0です。（**訳: ここはよくわかりません**）]
配列、ベクトルおよび行列の変数は、角括弧で整形されてプリントされます。
たとえば、3次元ベクトルは以下のようにプリントされます。

```
[1, 2, 3]
```

2×3次元行列はこのようになります。

```
[[1, 2, 3], [4, 5, 6]]
```

配列や行列をもっとも読みやすくプリントするバージョンはループを使ってできます。
以下は`transformed data`ブロックでの`print`文の使用例です。

```
transformed data {
  matrix[2, 2] u;
  u[1, 1] = 1.0;   u[1, 2] = 4.0;
  u[2, 1] = 9.0;   u[2, 2] = 16.0;
  for (n in 1:2)
    print("u[", n, "] = ", u[n]);
}
```

この`print`文は2回実行され、以下のような2行の出力をプリントします。

```
u[1] = [1, 4]
u[2] = [9, 16]
```

#### 入力はvoid以外

`print`関数の入力の型はvoidにはできません。
とくに気をつけるところで、ユーザー定義のvoid関数の結果も使えません。
ほかの型はすべて`print`関数の引数に使うことができます。

#### プリントの頻度

`print`文は、毎回実行されるたびにプリントします。
`transformed data`ブロックはchainごとに1回実行され、`transformed parameter`ブロックと`model`ブロックはリープフロッグステップごとに1回実行され、`generated quantities`ブロックはiterationごとに1回実行されます。

#### 文字列リテラル

文字列リテラルは二重引用符（`"`）で囲まれます。二重引用符の間の文字には、空白文字や、その他の目に見えるASCII文字を含めることができますが、バックスラッシュ（`\`）と二重引用符（`"`）は例外です。目に見えるASCII文字の完全なリストは以下になります。

```
a b c d e f g h i j k l m n o p q r s t u v w x y z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
0 1 2 3 4 5 6 7 8 9 0 ~ @ # $ % ^ & * _ ' ` - + = {
} [ ] ( ) < > | / ! ? . , ; :
```

#### `print`によるデバッグ

Stanは命令型の言語ですから、デバッグには`print`文は非常に便利です。
プログラム実行中のいろいろなところで、変数や式の値を表示するのに使うことができます。
とりわけ便利なのが、無限の値による非数の問題が発生するところを、その両方をプリントすることで発見するのに使うことです。

対数確率アキュムレーター（40.4節を参照）の値をプリントするのも非常に便利です。以下がその例です。

```
vector[2] y;
y[1] = 1;
print("lp before =", target());
y ~ normal(0,1);  // バグ!  y[2]は未定義
print("lp after =", target());
```

この例では、ベクトル`y`がサンプリング文で使われる前には`y[2]`が定義されていないというバグがあります。
対数確率アキュムレーターの値を各サンプリング文の前後でプリントすることにより、対数確率が定義不定（すなわち非数）となるところ特定することができます。

### 5.11. reject文

Stanでは`reject`文により、プログラム実行中に発生したエラーや問題のある値を報告し、プログラムを停止させるか、あるいはサンプルや最適化のiterationを却下するという仕組みを備えています。

`print`文と同様に`reject`文は、任意の数の、引用符で囲まれた文字列リテラルやStanの式を引数として受け付けます。

`reject`文は、不正な状態にある変数を検出するための条件文の中に置かれるのが普通です。
たとえば以下のコードでは、変数`x`の値が負になった場合を扱っています。

```
if (x < 0)
  reject("x は負ではいけません; 見つかった x=", x);
```

#### `reject`文の動作

`reject`文は、Stanの組み込み関数が投げる例外と同じように動作します。
たとえば、`normal_lpdf`関数は、入力されたスケールが正ではない有限の値のとき例外を発生させます。
`reject`文の効果は、却下の発生したプログラムブロックによって変わります。

どんな却下の場合でも、Stanのプログラムにアクセスするインターフェイスは`reject`文への引数をプリントするはずです。

##### 関数での却下

ユーザー定義関数での却下は、単に関数呼び出しかプログラムブロックに渡されるだけです。
`reject`文は、関数の引数をチェックするのに使うことができます。これにより、ユーザー定義関数を、組込み関数とまったく同じように動作させることができます。
問題があるときには、できるだけはやく見つけ出すようにするのがよいでしょう。

##### 致命的な例外となる状況

`transformed data`ブロックと`generated quantities`ブロックでは、却下は致命的なものとなります。
これは、初期化に失敗したり、出力の生成に失敗したりすると、値を回復する手段がないからです。

`transformed data`ブロックに置かれた`reject`文は、データと（あれば）変換データの値をチェックするのに使うことができます。
これにより、Stanの制約つき変数宣言を使って指定できるものより複雑な制約を課すことができます。

##### 回復可能な却下となる状況

`transformed parameters`ブロックと`model`ブロックでの却下は、それ自体はただちに致命的ではありません。
その場合の結果は、$-\infty$を対数確率に代入するのと同じ効果を持ちます。すなわち、MCMCサンプラーでは現在の提案が却下され、最適化では探索パラメーターの調整が行なわれます。

対数確率関数の結果が呼び出しのたびに却下となれば、それを含む実行（MCMCサンプラーあるいは最適化）はこの問題を診断し、適切なエラーメッセージを出して終了するでしょう。
プログラムの診断の補助のため、`reject`文ごとにその実行結果のメッセージがプリントされます。

#### 却下は制約ではありません

任意の制約を定義するほかに、却下はエラーハンドリングにも使えるでしょう。
エラーのある以下のStanプログラムを見てみましょう。

```
parameters {
  real a;
  real<lower=a> b;
  real<lower=a, upper=b> theta;
  ...
model {
  // **間違い** 明示的な切断が必要
  theta ~ normal(0, 1);
```

このプログラムは、`theta`の上下限がパラメーターに依存しており、明示的に分布を切断する必要がありますから、間違いです。
正しくはこのようにします。

```
theta ~ normal(0, 1) T[a, b];
```

概念的には、事前分布が、許容されるパラメーター空間全体で積分しても1にならないのが問題です。実数全体で積分すると1になりますから、$[a,b]$で積分しても1よりも小さな値にしかなりません。このような単純な単変量の場合では、`T[ , ]`記法により解決できますが、本質的には、事前分布を$[a,b]$で積分するように分割することになります。

この問題は、多変量関数に複雑な不等式の制約を課すのに`reject`文を使おうとするのとまったく同じ問題です。
この場合、制約により切断を扱おうとするのは間違いです。

```
if (theta < a || theta > b)
  reject("theta not in (a, b)");
// やはり**間違い**, T[a,b]が必要
theta ~ normal(0, 1);
```

この場合も事前分布は、複雑な不等式を満たすパラメーター空間の領域で積分しても1未満の値にしかなりません。
しかし、この事前分布を積分した値は一般にはわかりませんから、それを補正するように対数確率関数に加算を行なうことができません。

切断された事後密度の合計が無視できる、あるいは一定であるような特定のモデルでは、正則な確率モデルへ調整することは「大きな問題ではない」ように見えるかもしれません。しかしその場合でも、切断された事後分布から効率的にサンプリングすることはできません。
プログラムでは、制約を満たすことを保証する1対1のマッピングを使う必要があり、`reject`文の使用は、エラーを発生させることと、デバッグを支援することとに留める必要があります。
