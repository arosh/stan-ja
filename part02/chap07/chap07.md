## 7. ユーザー定義関数

Stanでは、ユーザーが独自の関数を定義することができます。その基本構文は、CやC++で使われるものの簡易版です。この章では、Stanで関数を宣言し、定義し、使う方法を述べます。よりプログラミング志向の観点での説明は23章を参照してください。

### 7.1. 関数定義ブロック

ユーザー定義関数は特別な関数定義ブロックの中に書かれます。このブロックは、ほかのすべてプログラムブロックの前に置かれます。

```
functions {
  // ... 関数宣言と定義 ...
}
data {
  // ...
```

関数は使う前に宣言しなければいけません。この条件に従う限り、関数の定義と宣言はどのような順番でも構いません。再帰関数を使えるようにするために前方宣言も許されています。

### 7.2 関数名

関数の命名および関数の引数の命名の規則はほかの変数と同様です。有効な識別子についてさらに知るには4.2節を参照してください。例えば、

```
real foo(real mu, real sigma);
```

は、2つの引数の変数を持つ`foo`という名前の関数を宣言し、引数の変数の型は`real`および`real`です。このときの引数の名前は`mu`と`sigma`ですが、これは宣言の一部ではありません。たとえ引数の型の順序が異なっていたとしても、別のユーザー定義関数に同じ名前をつけることは**できません**。

### 7.3. 関数呼び出し

関数の引数はすべて必須です。デフォルトの値はありません。

#### 式としての関数

返り値の型がvoidでない関数は、ほかのすべてのStanの組み込み関数とまったく同様に呼ばれます。適切な型の引数を与えられて、式を生成します。この式は、実行されたときに値を持ちます。

#### 文としての関数

返り値の型がvoidの関数は、引数を与え、文のように使うことができます。サンプリング文やプリント文のように働きます。そのような使い方ができるのは、対数確率アキュムレーターに値を加えるとか、プリントとか、例外を発生させるといった副作用によって機能する関数だけです。

#### サンプリング文中の確率関数

名前が`_lpdf`あるいは`_lpmf`で終わる関数（密度あるいは質量関数）は確率関数として使えます。また、サンプリング文の右側の、パラメーター化した分布の場所に使うこともできます。このような関数が使える場所に制限はありません。

#### 場所の制限

ある種の関数は使えるスコープに制限があります。名前が`_lp`で終わる関数は、対数確率アキュムレーターにアクセスできることになっており、`transformed parameters`および`model`ブロックでのみ使用可能です。名前が`_rng`で終わる関数は、乱数発生器にアクセスできることになっており、`generated quantities`および`transformed data`ブロックと、`_rng`で終わるユーザー定義関数内でのみ使用できます。この2つの特別な種類の関数についてさらに知るには、7.5節を参照してください。

### 7.4. 引数の型にサイズはありません

Stanの関数はすべて、引数と返り値の両方について、宣言された型を持ちます。組み込み関数と同じく、ユーザー定義関数は、基本引数型と次元数だけで宣言されます。このことから、ほかの変数を宣言するのとは別の構文が必要になります。返り値の型と引数の型とで同じ宣言の構文が使えるように言語が設計されました。

`void`型を引数の型に使うことはできません。副作用のある関数の返り値にだけ使えます。

#### 基本変数型の宣言

基本変数型は、`integer`および`real`、`vector`、`row_vector`、`matrix`です。上限あるいは下限の制約は使えません（例えば、`real<lower=0>`は違反です）。特別な型も使えません（例えば、`simplex`は違反です）。

#### 次元数の宣言

引数と返り値の型には配列が使えます。これには、インデックス操作に使われる角括弧とコンマをつけて示します。例えば、`int`は1個の整数の引数あるいは返り値を示しますが、`real[ ]`は実数の1次元配列を、`real[ , ]`は2次元配列を、`real[ , , ]`は3次元配列を示します。いつもどおり空白は省略可能です。

ベクトルと行列の次元は含まれませんから、`matrix`は1個の行列の引数あるいは返り値の型です。したがって、もし変数が`matrix a`と宣言されれば、`a`のインデックス操作の次元数は2ですから、`a[1]`は行ベクトルで、`a[1, 1]`は実数値です。行列は暗黙のうちに2次のインデックス操作の次元を持ちます。型宣言`matrix[,] b`は、`b`が行列の2次元配列であると指定しています。ですから、合計でインデックス操作の次元数は4となり、`b[1, 1, 1, 1]`が実数値を取り出します。

#### 次元数のチェックと例外

関数の引数と返り値の型はそれ自身は次元数のチェックを受けません。どんなサイズの行列でも、行列引数として渡せます。それにもかかわらず、ユーザー定義関数は、自身で次元数のチェックをする関数（多変量正規密度など）を呼び出すかもしれません。

関数の返り値の次元は、前もって宣言した変数に代入される場合にチェックされます。関数の引数として使われるときにもチェックされることがあります。

ユーザー関数の中での関数呼び出しや、戻り値の型の不整合により発生したエラーはすべて単に次の処理に渡されるだけです。通常は、警告メッセージと、サンプリングや最適化の途中で提案された値が却下されるということになります。

### 7.5. 関数本体

関数の本体は波括弧（`{`と`}`）で囲まれます。本体には、関数本体ブロックの先頭に局所変数の宣言を含めることができます。そのスコープは、ほかの文ブロックすべてで使われる通常の局所変数と同じです。

関数本体内の文について制限するかどうかだけは本体の外側に書かれます。この制限により、対数確率アキュムレーターあるいは乱数発生器が利用可能かどうかが決まります。詳細はこの節のこれ以降を参照してください。

#### 乱数発生関数

乱数発生関数を本体内で呼ぶ関数は、名前を`_rng`で終わるようにしなくてはいけません。そうなっていない関数で乱数発生器を使おうとすると、コンパイル時のエラーになります。

ほかの乱数発生関数と同様に、名前が`_rng`で終わるユーザー定義関数も、`generated quantities`ブロックと`transformed data`ブロック、あるいは`_rng`で終わるユーザー定義関数の本体内部でのみ使えます。それ以外の場所でそのような関数を使おうとすると、コンパイル時のエラーになります。

#### 関数中での対数確率へのアクセス

サンプリング文あるいは対数確率増加文を含む関数は`_lp`で終わる名前でなくてはいけません。サンプリング文あるいは対数確率増加文をほかの関数で使おうとすると、コンパイル時のエラーになります。

`target`対数確率増加文とサンプリング文と同様に、名前が`_lp`で終わるユーザー定義関数も、対数確率アキュムレーターにアクセス可能なブロック、すなわち`transformed paramters`および`model`ブロックでのみ使えます。それ以外の場所でそうした関数を使おうとすると、コンパイル時のエラーになります。

#### サンプリング文用の確率関数の定義

名前が`_lpdf`および`_lpmf`（密度および質量関数）で終わる関数は、確率関数としてサンプリング文で使うことができます。組込み関数と同様に、最初の引数はサンプリング文中では、サンプリング文演算子（`~`）の左側に置かれます。その他の変数はその後に続きます。例えば、与えられたパラメーター`theta`について`y`の密度の対数を返し、サンプリング文中で使える関数とすると、以下のように定義します。

```
real foo_lpdf(real y, vector theta) { ... }
```

関数定義で注意するのは、縦棒ではなくコンマを使うことです。そうすると、

```
z ~ foo(phi);
```

という短い記法は以下とまったく同じになります。

```
target += foo_lpdf(z | phi);
```

組込みの確率関数とは違って、上の`foo`の例のようなユーザー定義の確率関数では定数項を自動的には除外しません。

同じ構文と短い記法が、`_lpmf`という接尾辞の対数確率質量関数でも機能します。

分布としてアクセスされる関数は、定義する密度あるいは質量の対数を返さなくてはいけません。

### 7.6. パラメーターは定数

関数定義の本体では、パラメーターはほかの変数と同じように使えます。しかしパラメーターは、代入できない（すなわち、代入（`=`）文の左側に置くことはできません）という意味で定数です。言い換えると、その値は関数本体の中ではずっと変わりません。関数のパラメーターの値に値を代入しようとすると、コンパイル時のエラーが発生します。^[Stanでは、定数と宣言され、値渡し構文であるように見えますが、言語の実装としては、C++の定数参照で関数の引数に渡されます。]

局所変数は`functions`ブロックの先頭で宣言することができます。スコープはほかと同じです。

### 7.7 返り値

非void関数には、適切な型の式を返す`return`文が必要です。もし、`return`文の式が、関数が返すと宣言した返り値の型と違うときには、コンパイル時のエラーが発生します。

void関数では、引数なしで`return`だけを使うことができますが、`return`文は必須ではありません。

#### 返る保証が必要

C++とは違ってStanでは、制御が非void関数を離れる場合について、適切に型付けされた`return`文によるか、あるいは関数実行中での例外の発生によると、構文上も保証することが非void関数に対し義務づけられています。この条件を確実にするため、本体の最後の文として`return`文が関数には必要です。この場合の最後という概念は、関数の本体として資格のある文という点から再帰的に定義されます。基本的な場合は

- `return`文が資格を満たす

再帰的な場合は

- 最後の文が資格を満たすなら、一連の文が資格を満たす
- その本体が資格を満たすなら、`for`ループあるいは`while`ループが資格を満たす
- デフォルトの`else`節があり、その本体の文が資格を満たすなら、条件文が資格を満たす

この規則は以下の場合は不適格となります。

```
real foo(real x) {
  if (x > 2) return 1.0;
  else if (x <= 2) return -1.0;
}
```

これは、デフォルトの`else`節がないからです。

```
real foo(real x) {
  real y;
  y = x;
  while (x < 10) {
    if (x > 0) return x;
    y = x / 2;
  }
}
```

これも、`return`文がwhileループの最後の文ではないので不適格です。この場合、無駄なダミーの`return`を`while`ループの後に置くことができます。この`return`のルールでは、以下は許されます。

```
real log_fancy(real x) {
  if (x < 1e-30)
    return x;
  else if (x < 1e-14)
    return x * x;
  else
    return log(x);
}
```

デフォルトの`else`節があり、どの条件の中身にも最後の文として`return`があるからです。

### 7.8. 文としてのvoid関数

#### void関数

返り値の場所に`void`を使うことで、返り値のない関数を宣言できます。`void`型は返り値の型としてのみ使えることに注意しましょう。引数を`void`型と宣言することはできません。

#### 文としての使い方

`void`関数は、関数宣言した後で文として使えます。宣言の規則は7.9節を参照してください。

`return`がありませんから、その使い方はもっぱら副作用のためになります。例えば、対数確率の加算、表示、エラー発生です。

#### 特殊なreturn文

`void`関数の定義中の`return`文では、`return`というキーワードのすぐ後に、値を返す式ではなく、セミコロン（`;`）が続きます。

### 7.9. 宣言

一般に、関数は使う前に宣言しなくてはいけません。Stanでは、前方宣言が使えます。これは、本体のない関数定義のように見えます。例えば、

```
real unit_normal_lpdf(real y);
```

は、1個の実数値の入力と実数値の出力をもつ`unit_normal_lpdf`という関数を宣言します。本体のある関数定義では、名前付きの関数の宣言と定義を同時におこないます。例えば、以下です。

```
real unit_normal_lpdf(real y) {
  return -0.5 * square(y);
}
```

ユーザー定義のStan関数は宣言しておいて、後で定義したり、宣言なしで定義だけすることもできます。その他の宣言と定義の組み合わせはどれも規則に合うものではありません。したがって、例えば、関数を2度以上宣言することはできませんし、2度以上定義することもできません。宣言があれば、定義しなくてはいけません。この規則はともに、宣言された関数が最終的にすべて定義されていることを保証するものです。

#### 再帰関数

前方宣言により、自己再帰あるいは相互に再帰的な関数を定義できます。例えば、フィボナッチ数を計算する以下のコードを考えます。

```
int fib(int n);

int fib(int n) {
  if (n < 2) return n;
  else return fib(n-1) + fib(n-2);
}
```

1行目の前方宣言がないと、定義本体はコンパイルできないでしょう。
