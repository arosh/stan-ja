## 43. スパースな行絵rつの操作

スパースな行列とは，多くの要素がゼロであり，メモリーをセーブするために特別な表現方を使った方がより効果的ですし，行列操作(同関数の計算など)もスピードアップできます。Stanの実装の仕方を使えば，実際にスパース行列が使う(メモリ)空間を抑えることができます。密な行列の操作を最適化するのを簡単にできるので，90%かそれ以上のスパースな行列の時はスピードの改良が見込まれます。そのレベルほどではないなら，密な行列として計算する方が早いですが，メモリはたくさん消費します。

スピードアップとメモリの使用を抑えるためには，ベクトルの掛け算を始める前に，密な行列として読んでから，それをスパースな行列に置き換えた方が良いかもしれません。この章は，スパースな行列用の非常に特別な書式を解説するもので，密なベクトルをスパースな行列にかけたりする内容を含んでいますが，Stanでスパースなデータ構造を持つものに対してもっと一般的なコーディング方法が知りたければ，16章をみてください。

### 43.1 行のメモリを圧縮する
Stanでは，スパース行列は行メモリ圧縮(compressed row storage,CSR)法で表現されます。例えば，行列

$$  A=\left[\begin{array}{cccc}{19} & {27} & {0} & {0} \\ {0} & {0} & {0} & {0} \\ {0} & {0} & {0} & {52} \\ {81} & {0} & {95} & {33}\end{array}\right]  $$

は，行列$A$から行ごとに読み込んだ非ゼロの実数ベクトルに書き換えられ，

$$w(A)=\left[\begin{array}{llllll}{19} & {27} & {52} & {81} & {95} & {33}\end{array}\right]^T$$

となり，ここで値の列インデックスをもつ整数配列，

$$v(A)=\left[\begin{array}{llllll}{1} & {2} & {4} & {1} & {3} & {4}\end{array}\right]$$

と，$w(A)$のどこから所与の行の値がスタートするかを示すインデックスを持つ整数配列，

$$u(A)=\left[\begin{array}{lllll}{1} & {3} & {3} & {4} & {7}\end{array}\right]$$

が，保証のために数値を次のように詰め合わせたもの，

$$ u(A)\left\[n+1\right\] - u(A)\left\[n\right\]$$

と一緒にされます。最後の数字は，もとの行列における第$n$行目の非ゼロの要素の数(ここではそれぞれ2,0,1,3です)を表しています。二行目は非ゼロの要素を持っていないので，$u(A)$での第二，第三の要素と，それに対応する$w(A)$の第三の要素が52であることに注意してください。$(w(A),v(A),u(A))$の数字があれば，$A$を再構成するには十分なのです。

この数字は構造化されており，実数と整数をもつ各非ゼロ要素の列インデックス配列，マトリックスの各行プラス1の整数配列，詰め合わせ用のプラス1の整数配列からなります。また，内部の要素ポインタとサイズについてのメモリも背後に存在します。全体としてのメモリ使用量は，大体12K+Mバイトプラス，わずかな定数オーバーヘッドです。これは，密な行列が保持する$M \times N$よりも大抵はかなり少ないサイズで済みます。むしろより大切なことは，ゼロの値は掛け算や足し算の時には導関数の計算には影響しないことで，そのことで，スパースな行列を計算する時は，かなりのメモリと評価のステップが抑えられるということです。
