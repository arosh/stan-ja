## 11. 欠測データと部分的に既知のパラメーター

ベイズ推定では欠測データに対してごく一般的な手法を使えます。すなわち、欠測データの項目はすべて、事後分布で推定されるパラメーターとして表されるというものです(Gelman et al., 2013)。たいていの回帰モデルの予測変数では欠測データが明示的にモデル化はされませんが、そのような場合の結果は、欠測している予測変数を表すパラメーターの非正則事前分布そのものです。

観測データと欠測データを同じ配列に含めるという方法はStanでは扱いにくいことがあります。その理由の1つは、離散の未知量をモデル化する方法がStanではトリッキーになりがちだからです。また別の理由は、ほかのいくつかの統計言語（例えば、RやBUGS）とは違ってStanでは、観測量と未知量はモデル中の別の場所で定義する必要があるからです。そのためStanのプログラムでは、データ構造中の観測部分と欠測部分とを継ぎ合わせるコードを含める必要がある場合があります。例はこの章でこの後から紹介します。

### 11.1. 欠測データ

Stanでは、`data`と`transformed data`ブロックで宣言された変数を既知量として、`parameters`ブロックで宣言された変数を未知量として扱います。

正規分布に従う観測値に欠測データを含む例^[もっと意味のある推定の例としては、観測された観測値と欠測の観測値とがあり、それぞれについての予測変数は既知で`data`ブロックで指定されているような回帰があるでしょう。]は以下のようにコーディングできるでしょう。

```
data {
  int<lower=0> N_obs;
  int<lower=0> N_mis;
  real y_obs[N_obs];
}
parameters {
  real mu;
  real<lower=0> sigma;
  real y_mis[N_mis];
}
model {
  y_obs ~ normal(mu, sigma);
  y_mis ~ normal(mu, sigma);
}
```

観測データ点と欠測データ点の数は、非負の整数の変数`N_obs`と`N_mis`にデータとしてコーディングされています。観測データは、配列のデータの変数`y_obs`として与えられています。欠測データは配列のパラメーター`y_mis`としてコーディングされています。推定される通常のパラメーターである、位置`mu`とスケール`sigma`もパラメーターとしてコーディングされています。このモデルは、観測データと欠測データについてベクトル化されています。この例でそれらを結合させると効率が落ちるでしょう。これは、データである観測値が昇格して、必要のない導関数が計算されるためです。

### 11.2. 部分的に既知のパラメーター

多変量の確率関数で、一部の結果やパラメーターだけが観測されているといったような状況では、既知量（データ）と未知量（パラメーター）とを混ぜたベクトルを作る必要があります。Stanでこれをおこなうのは、`transformed parameters`ブロックでベクトルあるいは配列をつくり、それに代入することで可能です。

以下の例は、2変数の共分散行列を含むもので、分散は既知ですが、共分散は既知ではありません。

```
data {
  int<lower=0> N;
  vector[2] y[N];
  real<lower=0> var1;
}
transformed data {
  real<lower=0> var2;
  real<lower=0> max_cov = sqrt(var1 * var2);
  real<upper=0> min_cov = -max_cov;
}
parameters {
  vector[2] mu;
  real<lower=min_cov, upper=max_cov> cov;
}
transformed parameters {
  matrix[2, 2] Sigma;
  Sigma[1, 1] = var1;  Sigma[1, 2] = cov;
  Sigma[2, 1] = cov;   Sigma[2, 2] = var2;
}
model {
  y ~ multi_normal(mu, Sigma);
}
```

分散は、変数`var1`および`var2`にデータとして定義されていますが、共分散は、変数`cov`にパラメーターとして定義されています。2×2共分散行列`Sigma`は変換パラメーターとして定義されています。分散は、2つの対角要素に代入され、共分散は、2つの非対角要素に代入されます。

共分散の宣言につけた制約により、結果の共分散行列`Sigma`が正定値であることが保証されます。分散の積の、正負の平方根が上下限となりますが、この値は`transformed data`として定義されるので、計算されるのは1回だけです。

多変量正規分布のベクトル化がこのモデルの効率化の肝です。変換パラメーター`Sigma`は、`model`ブロック内で局所変数とし定義することもできるでしょう。

### 11.3. 欠測データのスライシング

何らかの長いデータ構造の中に欠測データがあるときも、多くの場合、インデックス配列とスライシングを使って効率的にデータ組み立てなおすことができます。以下は、系列のうちの一部しか観測されていない時系列データの例です。

```
data {
  int<lower = 0> N_obs;
  int<lower = 0> N_mis;
  int<lower = 1, upper = N_obs + N_mis> ii_obs[N_obs];
  int<lower = 1, upper = N_obs + N_mis> ii_mis[N_mis];
  real y_obs[N_obs];
}
transformed data {
  int<lower = 0> N = N_obs + N_mis;
}
parameters {
  real y_mis[N_mis];
  real<lower=0> sigma;
}
transformed parameters {
  real y[N];
  y[ii_obs] = y_obs;
  y[ii_mis] = y_mis;
}
model {
  sigma ~ gamma(1, 1);
  y[1] ~ normal(0, 100);
  y[2:N] ~ normal(y[1:(N - 1)], sigma);
}
```

インデックス配列`ii_obs`と`ii_mis`は、観測データ（データベクトル`y_obs`としてコーディングされています）と欠測データ（パラメーターベクトル`y_mis`としてコーディングされています）とからなる最終的な配列`y`へのインデックスを格納しています。時系列データについてもっと知るには10章を参照してください。`y`のベクトル化の説明や、この例を完全なAR(1)モデルになおす方法については10.1節を参照してください。欠測の場合でも`y[1]`が正則な事後分布を持つことを保証するため、幅は広いですが明示的な事前分布を与えています。

もうひとつありうる応用例は、一部の予測変数が欠測となっている、予測変数のデータ行列の列を補うというものです。行列の列はベクトルとしてアクセスでき、同様に代入できます。

```
x[N_obs_2, 2] = x_obs_2;
x[N_mis_2, 2] = x_mis_2;
```

ここで、対応する変数はすべてインデックス2としてハードコーディングされています。これは、Stanでは不ぞろいな配列が使えないからです。もっとこまごまとしたインデックス操作で長いベクトルからベクトルを切りだして、1つの配列にすべてまとめることもできるでしょう（Stanで、不ぞろいなデータ構造をコーディングする方法について一般的な議論は16.2節を参照してください）。

### 11.4. 因子分析の負荷行列

Rick Farouniは、Stan users groupで、単位対角の共分散行列についてCholesky因子をつくる方法を尋ねました。これは、ベイズ因子分析(Aguilar and West 2000)で使われます。対角下の要素をパラメーターとして宣言し、それから変換パラメーターとした行列全体に値を埋めることで、これを行なうことができます。

```
data {
  int<lower=2> K;
}
transformed data {
  int<lower=1> K_choose_2;
  K_choose_2 = (K * (K - 1)) / 2;
}
parameters {
  vector[K_choose_2] L_lower;
}
transformed parameters {
  cholesky_factor_cov[K] L;
  for (k in 1:K)
    L[k, k] = 1;
  {
    int i;
    for (m in 2:K) {
      for (n in 1:(m - 1)) {
        L[m, n] = L_lower[i];
        L[n, m] = 0;
        i = i + 1;
      }
    }
  }
}
```

事前分布は、`L_lower`に直接置くのが最も便利です。もうひとつの方法は、Cholesky因子`L`全体への事前分布でしょう。`L_lower`から`L`への変換では値は変わらないので、（訳注: 確率変数の変換に伴う）ヤコビアンの調整を必要としないからです（必要としないにもかかわらず、パーサから警告が出ます。これはパーサがコード解析をして変換が線形であると推測するほど十分に賢くないためです。）。共分散行列`L * L'`全体に事前分布を置くのは、ヤコビアン調整が必要となるでしょうから、まったく便利ではないでしょう。正確な調整は、共分散行列を扱う34.1節の小節で示します。

#### 11.5. 欠測の多変量データ

多変量の結果変数のうちの1つ以上の成分が欠測であるという場合はよくあります^[これは、回帰の問題で多変量の予測変数中の欠測成分と同じではないことに注意しましょう。その場合は、欠測データをパラメーターにして、回帰に使うために欠測値を補完する必要があるでしょう。]。例として、2変量の分布を考えましょう。これは用意に周辺化できます。ここでのコーディングは力まかせで、観測値のベクトルの配列`y`と、観測された値かどうかを示す論理値の配列`y_observed`の両方を使います（観測されていない部分は入力中ではダミーの値でかまいません）。

```
vector[2] y[N];
int<lower=0, upper=1> y_observed[N, 2];
```

両方の成分が観測されていれば、完全な多変量正規分布を使ってモデリングしますし、そうでなければ、観測された成分の周辺分布をモデリングします。

```
for (n in 1:N) {
  if (y_observed[n, 1] && y_observed[n, 2])
    y[n] ~ multi_normal(mu, Sigma);
  else if (y_observed[n, 1])
    y[n, 1] ~ normal(mu[1], sqrt(Sigma[1, 1]));
  else if (y_observed[n, 2])
    y[n, 2] ~ normal(mu[2], sqrt(Sigma[2, 2]));
}
```

ちょっと手間ですが、上のサンプリング文をベクトル化するとはるかに効率的になります。上の3通りの場合なら、`transformed data`で、3つのインデックスのベクトルを組み立てます。

```
transformed data {
  int ns12[observed_12(y_observed)];
  int ns1[observed_1(y_observed)];
  int ns2[observed_2(y_observed)];
}
```

3通りのサンプリングの場合分けそれぞれについての観測のカウント数を取り出す関数を書く必要があります。結果をトップレベルの変数のサイズ宣言に使う必要があるので、これは関数でおこなわなくてはいけません。つづいて、`transformed data`の残りの部分で、3つのカウンターを使って値を埋めます。

```
int n12 = 1;
int n1 = 1;
int n2 = 1;
for (n in 1:N) {
  if (y_observed[n, 1] && y_observed[n, 2]) {
    ns12[n12] = n;
    n12 = n12 + 1;
  } else if (y_observed[n, 1]) {
    ns1[n1] = n;
    n1 = n1 + 1;
  } else if (y_observed[n, 2]) {
    ns2[n2] = n;
    n2 = n2 + 1;
  }
}
```

すると、`model`ブロックでは、`transformed data`で1度につくられたこれらインデックスをつかってうまくベクトル化できます。

```
y[ns12] ~ multi_normal(mu, Sigma);
y[ns1] ~ normal(mu[1], sqrt(Sigma[1, 1]));
y[ns2] ~ normal(mu[2], sqrt(Sigma[2, 2]));
```

結果は、欠測データに潜在変数を使うよりもはるかに効率的でしょう。しかし、多変量分布を解析的に周辺化する必要があります。3つの配列を`transformed data`ブロックで事前に計算することもさらに効率よくしているでしょうが、確率関数のベクトル化にくらべると効率の改善への寄与は相対的に小さいでしょう。

一般的な多変量の事例にも、インデックスを多少いじれば、この手法は簡単に一般化できます。欠測成分についての共分散行列の要素を取り出すところが技です。振り子の時間と位置しか記録していない（運動量を記録していない）相空間実験のような、1つの成分しか観測されていない多変量微分方程式の解法のような場合にもこの技は使えます。

